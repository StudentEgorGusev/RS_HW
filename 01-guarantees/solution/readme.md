Лог успешной посылки (8 баллов) положил в proofs/tests\_m100\_c\_o.txt , скрин там же image.png





......Гарантии доставки сообщений (AnySystem)

....Питч идеи:

..Сделано 4 режима, от слабого к сильному. Я везде делаю одно и то же ядро: нумерую сообщения seq (это важно, т.к. текст не уникален),

а дальше уже по гарантии:

..AMO: sender шлет 1 раз, receiver старается не повторять доставку и не хранить все подряд.

..ALO: sender шлет и ретраит пока не получит ACK (можно дубли), receiver всегда доставляет, и всегда отвечает ACK.

..EO: как ALO, но receiver не допускает повторной локальной доставки (дедуп по seq), при этом не храню все id за жизнь.

..EOO: как EO + receiver доставляет строго по порядку seq (буферизую out-of-order).

..Сеть может терять/дублировать/мешать порядок, поэтому я нигде не опираюсь на пришло 1 раз и в том же порядке



....Поля и сокращения (основные)

..self.\_id - айди процесса

..self.\_receiver - айди получателя (у sender)

..seq - номер сообщения (логический id), растет у sender на каждое локальное MESSAGE

..self.\_next\_seq:

...у sender: следующий seq который выдать

...у receiver: следующий ожидаемый seq (который считаю “самый левый”)

..self.\_base - левый край окна (seq который сейчас ждём/ретраим в первую очередь)

..self.\_window - размер окна (сколько сообщений держу “в полёте” без ack)

..self.\_unacked - словарь seq -> text, то что уже отправил, но ack ещё нет (нужно для ретрая)

..self.\_pending - очередь текстов которые пришли локально, но пока не влезли в окно

..self.\_timer / self.\_timeout - таймер ретрая и его задержка

..self.\_timer\_active - пометка что таймер сейчас стоит (чтоб не иметь лишних set/cancel)



..Для receiver:

..self.\_buffer - буфер out-of-order сообщений (seq в text), нужен для ordered (и частично для AMO чтоб не сливать порядок прям совсем)

..self.\_max\_buffer - ограничение буфера для AMO, чтобы не раздуваться в плохой сети

..self.\_seen - структура “видел/доставил уже” для EO:

сделал компактно через bytearray как кольцо (ring), чтобы память не улетала как в set()



......Типы сообщений

....локальные:

..MESSAGE{text} - приходит senderу от пользователя S

..MESSAGE{text} - уходит receiverом пользователю R (должно быть 1в1 по типу и полям)

....сетевые:

..DATA{seq, text} - полезная нагрузка с номером

..ACK{seq} - подтверждение что receiver это DATA видел (для ALO/EO/EOO)



Также нигде не хэшу текст сообщения как идентификатор. Два одинаковых текста считаю разными сообщениями если разные seq.



================================================================================



......Не более одного раза (AMO)

....Идея:

..Гарантия повторов нельзя, но доставку при потерях не обещаю. Поэтому sender вообще без ретраев: 1 DATA на 1 локальное сообщение.

..Повторы приходят только от сети (dup), receiver их режет.

..Чтобы не хранить всё что видел, я держу next\_seq и маленький буфер опережающих.



....AtMostOnceSender

..on\_local\_message:



беру text



выдаю seq = self.\_next\_seq, ++



отправляю DATA(seq,text) ровно 1 раз



....AtMostOnceReceiver

..Логика:



если пришло seq < next\_seq: это дубль/старое, не доставляю



если seq == next\_seq: доставляю, двигаю next\_seq, потом пытаюсь схлопнуть буфер по порядку



если seq > next\_seq: кладу в \_buffer (если его там не было), т.е. жду пока ghj,tk закроется



если сеть плохая и буфер растёт:  делаю skip-ahead - перепрыгиваю на минимальный seq в буфере



....Свойства AMO

..No Duplication:

receiver доставляет только если seq == next\_seq (и дальше по буферу ровно по порядку), повторная доставка по одному seq не проходит

..Validity (в надежной сети):

sender шлет DATA, оно доезжает, receiver доставляет, т.к. дырок нет и буфер почти не нужен

..No Creation:

локальная доставка делается только по пришедшему data



================================================================================



......Не менее одного раза (ALO)

....Идея:

..Надо чтобы каждое сообщение дошло, даже если сеть подводит. Самое простое: sender хранит unacked и ретраит пока не увидит ACK.

..Повторы допустимы, поэтому receiver не обязан дедупить, просто доставляет всё что видит.



....AtLeastOnceSender

..Окно + ретрай:



держу окно self.\_window, чтобы не отправлять 1000 сообщений сразу и не упаст по памяти/сети



unacked хранит только то что уже реально отправил и ещё не ackнуто



pending это то что пришло локально, но ждёт пока освободится окно



..on\_local\_message:



если есть место в окне: кладу в unacked и шлю дата



если забито: кладу text в pending



таймер ставлю только когда unacked стало не пустое (первый пакет), чтоб не было лишних аларм



..on\_message (ACK):



удаляю seq из unacked (если он там есть)



двигаю base вправо пока base не упрётся в реально неакнутый



если unacked опустело: убираю таймер



если base сдвинулся и ещё есть unacked- перезапускаю таймер (чтоб ретрай был от актуального base)



засовываю pending в окно (try\_send\_pending)



..on\_timer:



ретраю только base (самый левый неакнутый), а не всё сразу

это специально чтоб в норм сети не складирвоать лишний трафик



....AtLeastOnceReceiver

..on\_message(DATA):



сразу deliver локально MESSAGE{text}



сразу отправляю ACK(seq) назад sender-у



....Свойства ALO

..Validity:

если sender ретраит бесконечно, то при предположении “если повторять, то когда-то дойдёт” сообщение дойдёт и будет доставлено

..No Duplication:

не требуется, поэтому я не режу повторы на receiver, дубли возможны по сети и это ок

..No Creation:

доставка только по полученному DATA



================================================================================



......Ровно один раз (EO)

....Идея:

..sender ровно как в ALO (иначе не будет reliable при dropах), а ровно-один-раз обеспечиваю на receiver:

если seq уже доставлял, то второй раз не доставляю.

..храню только просторанство вокруг next\_seq в виде окна seen (кольцо).

..Т.е. то что сильно старое (< next\_seq) точно доставлено/пропущено и больше не нужно помнить, а то что далеко вперёд тоже не коплю бесконечно.



....ExactlyOnceSender

..полностью как ALO sender: unacked + ack + ретрай base



....ExactlyOnceReceiver

..Состояние:



next\_seq (левый край)



bytearray seen как ring на диапазон \[next\_seq .. next\_seq+win)

seen\[offset]=1 означает это сообщение с таким offset уже было доставлено раньше (из out-of-order)

..Поведение:



если seq < next\_seq: это старьё/дубль, не доставляю, но ACK отправляю (чтоб sender заткнулся)



если seq == next\_seq: доставляю, двигаю next\_seq, потом пока seen у головы = 1, просто “пролистываю” дальше (т.е. эти сообщения уже доставлены раньше out-of-order)



если seq > next\_seq:



если seen для этого offset ещё 0: ставлю 1 и доставляю



если уже 1: значит повтор, не доставляю



ACK отправляю всегда



....Свойства EO

..No Duplication:

один seq локально доставляю максимум 1 раз (или через ветку offset==0, или через seen-метку)

..Validity:

sender ретраит до ack, значит receiver хотя бы раз увидит DATA и доставит

..No Creation:

как и везде



================================================================================



......Ровно один раз и с сохранением порядка (EOO)

....Идея:

..Тут уже нельзя доставлять out-of-order, значит receiver должен буферизовать опережающие seq.

..sender остаётся как ALO/EO (unacked + ack), но я специально делаю окно маленьким, чтобы:



меньше состояний в model checking



меньше памяти на receiver буфер (не улетает вперёд)



....ExactlyOnceOrderedSender

..логика та же что и ALO sender:



окно маленькое (self.\_window)



ретрай только base, а не всё



таймер только когда unacked не пустое



....ExactlyOnceOrderedReceiver

..on\_message(DATA):



если seq < next\_seq: дубль/старое, не доставляю, шлую ACK



если seq == next\_seq:



доставляю



next\_seq++



flush(): пока в буфере есть next\_seq, достаю и доставляю по порядку



если seq > next\_seq:



кладу в буфер (если не было)



ACK всегда назад



....Свойства EOO

..Ordered:

deliver только по next\_seq и дальше по flush, значит порядок строго по отправке sender-а

..No Duplication:

для каждого seq доставляю не более 1 раза (в буфере храню по ключу seq, дубли не вставляются)

..Validity:

за счёт ретраев sender и того что receiver ACK-ает, в норм условиях всё доходит, а при drop’ах sender будет повторять



================================================================================



......Оптимизация

....Почему seq:

..Текст не уникален и размер произвольный, поэтому идентификация только через seq, а не по text.

....Почему окно:

..Если запомнить все (или все ids), память растёт линейно и улетает. Окно держит активное состояние маленьким.

....Почему таймер ретраит только base:

..Если ретраить всё окно каждый тик, то в надежной сети начинаются лишние отправки (плохой traffic/message\_count).

Ретрай только base даёт более спокойный протокол, и в сети почти всегда “1 DATA + 1 ACK” на сообщение.

....EO receiver и bytearray:

..set() на целых в питоне жирный по памяти. bytearray в разы компактнее, плюс можно логически “выкидывать” старое, двигая next\_seq.

....EOO receiver буфер:

..Буфер нужен для порядка, но я стараюсь ограничивать его размер косвенно через маленький sender window.

Компромис: маленькое окно может уменьшать throughput в очень плохой сети, зато модель-чекер не умирает и память не раздувается.



......Итог

..AMO: минимум сообщений и состояния, но при dropах могу терять, и это ок по условию.

..ALO: доставляет всегда, но допускает дубли, состояние sender держит только активное окно.

..EO: доставляет всегда и без дублей, за счёт дедуп на receiver без хранения всей истории.

..EOO: доставляет всегда, без дублей и по порядку, ценой буфера и меньшего окна.

