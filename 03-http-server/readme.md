# HTTP Сервер

В этом задании вам предстоит реализовать простой HTTP сервер, выполняющий функции хранилища файлов.

В дальнейшем на практике вы, скорее всего, будете использовать готовые библиотеки, в которых уже реализовали работу с HTTP. Но стоит хотя бы раз в жизни попробовать сделать это "руками", чтобы лучше прочувствовать протокол.

Самую правдивую информацию о формате сообщений HTTP вы сможете найти в [RFC](https://datatracker.ietf.org/doc/html/rfc2616#section-4).

Настоятельно рекомендуем прочитать всё условие перед тем, как приступать к решению.

## Требуемый функционал

Сервер должен запускаться из командной строки со следующими параметрами:

| Параметр              | Переменная окружения       | Значение по умолчанию | Описание                                                      |
|-----------------------|----------------------------|-----------------------|---------------------------------------------------------------|
| `--host`              | `SERVER_HOST`              | `0.0.0.0`             | Хост, на котором нужно слушать входящие соединения            |
| `--port`              | `SERVER_PORT`              | `8080`                | Порт, на котором нужно слушать входящие соединения            |
| `--working-directory` | `SERVER_WORKING_DIRECTORY` |                       | Абсолютный путь к директории, в которой будут храниться файлы |
| `--server-domain`     | `SERVER_DOMAIN`            | `localhost`           | Домен, на котором должен слушать сервер                       |

Если не передан параметр командной строки, то значением параметра будет значение из окружения. Если же значение переменной окружения не указано, нужно использовать значение по умолчанию.

Если не задан параметр `working-directory`, то нужно сделать `exit(1)`.

### Методы

Вашему серверу будут поступать запросы с указанием `{url}` (Request-URI из RFC), который всегда соответствует некоторому пути к файлу или директории относительно `working-directory`.

#### GET {url}

Если путь `{url}` соответствует файлу, то требуется вернуть его содержимое.

Если путь является директорией, то надо вывести таблицу всех файлов внутри директории в формате вывода `ls -lA` на Linux, например:

```
dr-xr-xr-x naorlov naorlov 100 2020-01-01 12:34:00 directory_name
-rwxr--r-- naorlov staff 100 2020-01-01 12:36:00 filename
```

Если клиент выразил желание получить данные в сжатом виде (передал заголовок `Accept-Encoding`), то данные должны быть сжаты указанным способом сжатия. Подробнее в разделе _Заголовки_.

Если путь отсутствует либо не является валидным путем, необходимо вернуть код ответа 404 и человеко-читаемый текст с описанием ошибки в теле ответа.

#### POST {url}

Создает новый файл или директорию на сервере по пути `{url}`, считая от `working-directory`. Данные файла передаются в теле запроса. Если передан заголовок `Create-Directory: True`, то необходимо создать по указанному пути директорию.

Если файл уже существует, то необходимо вернуть код ответа 409 и человеко-читаемый текст в теле ответа.

Если родительской директории по отношению к конечному файлу не существует (например, пришел запрос `POST /aba/caba/text.py`, но `/aba/caba/` не существует), вы вправе самостоятельно выбрать, что делать: можно создать промежуточные директории, а можно не создавать и вернуть ошибку.

#### PUT {url}

Обновляет содержимое файла по пути `{url}`, считая от `working-directory`. Новые данные файла передаются в теле запроса.

Если файл является директорией, то необходимо вернуть код ответа 409 и человеко-читаемый текст в теле ответа.

Если файла по заданному пути не существует, можно либо ничего не делать, либо создать его.

#### DELETE {url}

Удаляет файл или директорию по пути `{url}`, считая от `working-directory`. Если путь является директорией и в запросе не передан заголовок `Remove-Directory`, то нужно вернуть ответ 406. При успешном удалении вернуть 200.

## Компоненты задания и оценивание

Оценка будет ставиться на основе результатов автоматического тестирования. В процессе тестирования ваше решение будет много раз запускаться на случайных наборах файлов и директорий, и будет проверяться корректность обработки сгенерированных HTTP запросов.

Тесты состоят из нескольких групп. В некоторых группах требуется реализовать только подмножество полного решения, например в первой группе будет проверяться только работа GET запросов на существующих файлах. Также некоторые группы могут накладывать ограничения на содержимое файлов и не требовать обработки некоторых заголовков.

Для получения баллов за каждую группу необходимо чтобы ваше решение успешно прошло все тесты в этой группе.

| Баллы       | Описание группы                                        | (1) GET file  | (2) GET dir | (3) POST, PUT, DELETE | (4) Сжатие | (5) Заголовки | (6) Текстовые файлы | (7) Файлы < 8 MB |
|-------------|--------------------------------------------------------|---------------|-------------|-----------------------|------------|---------------|---------------------|------------------|
| **3** | G1. Только GET запросы к существующим текстовым файлам | + (no errors) | -           | -                     | -          | -             | +                   | +                |
| **1**  | G2. Только GET запросы к существующим файлам           | + (no errors) | -           | -                     | -          | -             | -                   | +                |
| **1**  | G3. Произвольные GET запросы                           | +             | + (simple)  | -                     | -          | -             | +                   | +                |
| **2** | G4. Простой файловый сервер                            | +             | + (simple)  | +                     | -          | -             | -                   | +                |
| **1**  | G5. Проверка домена, обработка MIME типов              | +             | + (simple)  | +                     | -          | +             | -                   | +                |
| **1**  | G6. Подробный листинг директории                       | +             | + (full)    | +                     | -          | -             | -                   | -                |
| **1**  | G7. Поддержка сжатия                                   | +             | + (full)    | +                     | +          | +             | -                   | -                |

**При отсутствии отчёта в `server/readme.md` проверка производиться не будет.** В нем надо описать структуру и детали реализации вашего сервера, а также используемые библиотеки, если они отличаются от заготовки.

### Ограничения
 
В таблице для каждой группы указаны ограничения на запросы и файлы, которые используются для тестирования. Баллы за группу будут начисляться только если ваше решение успешно прошло все тесты в этой группе, то есть только если ваше решение корректно работает на всех возможных запросах удовлетворяющих ограничениям этой группы. Ниже приведено описание данных ограничений.
                                                  
#### (1) GET file

`+ (no errors)` – GET запросы только к существующим файлам.

`+` – GET запросы по любым путям, в случае отсутствия файла ожидается что сервер вернет ошибку.

Учтите, что даже в случае группы G1 вы должны корректно обрабатывать запросы `GET / HTTP/1.1` 
и отправлять корректный HTTP ответ.

#### (2) GET dir

`-` – нет GET запросов к директориям.

`+ (simple)` – GET запросы к директориям возвращают список файлов в ней, в любом формате.

`+ (full)` – GET запросы к директориям возвращают список файлов в ней, а также размер и дату создания каждого файла.

Нужно вывести пользователю таблицу всех файлов внутри директории, представляющую информацию в следующем формате: является ли путь директорией, владелец файла, группа файла, размер inode в
байтах, дата, время, название:

```
dr-xr-xr-x naorlov naorlov 100 2020-01-01 12:34:00 directory_name
-rwxr--r-- naorlov staff 100 2020-01-01 12:36:00 filename
```

Подсказка: для получения этой информации под Linux можно вызвать утилиту `ls` с параметрами `-lA` и `--time-style`. Для локального тестирования на MacOS можно использовать `gls`.

#### (3) POST, PUT, DELETE

`-` – нет запросов на изменение файлов.

`+` – запросы на изменение файлов (POST, PUT, DELETE).

#### (4) Сжатие

`-` – не проверяется поддержка сжатия.

`+` – проверяется поддержка сжатия.

При проверке будет передаваться заголовок `Accept-Encoding: gzip`, в ответе ожидается `Content-Encoding: gzip`, в теле ответа должны передаваться данные, сжатые алгоритмом gzip (можно использовать библиотеки).

#### (5) Заголовки

Сервер должен поддерживать следующие заголовки для запросов и ответов:

| Заголовок          | Допустимые значения  | Использование | Описание                                                                                                                                                                                                      |
|--------------------|----------------------|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Host`             | Любой валидный домен | Запрос        | Клиент отправляет заголовок `Host` с каждым запросом к серверу. В случае, если при запуске сервера был указан параметр `server-domain` не совпадающий с заголовком `Host`, необходимо вернуть код ответа 400. |
| `Accept-Encoding`  | `gzip`               | Запрос        | Обозначает, что клиент готов принимать данные, сжатые указанным алгоритмом. Если не указан, данные сжимать не нужно.                                                                                          |
| `Create-Directory` | `True`, `False`      | Запрос        | Если указан И запрос с методом `POST`, то по указанному пути необходимо создать директорию.                                                                                                                   |
| `Remove-Directory` | `True`,`False`       | Запрос        | Если указан И запрос с методом `DELETE` запросом, то требуется удалить директорию по указанному пути.                                                                                                         |
| `Content-Length`   | Число                | Запрос, Ответ | Размер тела сообщения в байтах.                                                                                                                                                                               |
| `Content-Type`     | MIME-тип             | Ответ         | MIME-тип, обозначающий тип передаваемого контента. Для листинга директории можно вернуть `text/plain` или `text/html`, для остальных файлов любой валидный MIME-тип.                                          |
| `Content-Encoding` | `gzip`               | Ответ         | Обозначает, что данные ответа сжаты указанным алгоритмом. Если не указан, то данные ответа не являются сжатыми.                                                                                               |
| `Server`           | Строка               | Ответ         | Название вашего сервера.                                                                                                                                                                                      |

#### (6) Текстовые файлы
      
`+` – все файлы на диске и в запросах являются текстовыми в кодировке ASCII.

`-` – без ограничений на формат файлов, файлы могут содержать случайные байты.
                    
#### (7) Файлы < 8 MB

`+` – все файлы на диске и в запросах имеют размер не более 8 МБ.

`-` – без ограничений на размер файлов, файлы могут быть любого размера.

**Обратите внимание**, что в тестирующей системе ваше решение будет запускаться с ограничением на использование оперативной памяти – вашему решению будет доступно 128 MB. Размер файлов может превышать размер доступной оперативной памяти, в этом случае нужно читать и записывать файлы на диск, не загружая их в оперативную память. Проверить ваше решение с ограничениями на память можно локально, используя Docker для тестирования.

### Протокол

1. Является подмножеством протокола HTTP/1.1.
2. После отправки ответа клиенту сервер должен закрыть соединение.

Для простоты будем считать, что сервер не должен уметь обрабатывать несколько соединений одновременно. На практике это конечно же не так, и обработка соединений происходит в разных потоках или асинхронно.

## Требования к реализации и заготовка

**Ваша реализация не должна использовать готовые библиотеки для работы с HTTP**, парсинга его сообщений и т.п., доступные в интернете или в стандартной библиотеке вашего языка. Максимально доступный уровень — реализация TCP сервера, например `socketserver.TCPServer` в Python. Можно использовать библиотеки для работы с файлами, сокетами, командной строкой и т.п.

Код заготовки на Python находится в папке `server`. Вы можете написать решение на основе этого кода, либо использовать любой другой язык, так как для тестов необходим только описанный выше CLI интерфейс. В файле `server/Dockerfile` должно находиться описание сборки Docker образа вашего сервера, используемое в тестах.

Весь код решения должен размещаться в папке `server`. При сдаче решения в тестирующую систему отправляется только эта папка, изменения вне неё учитываться не будут.

## Тестирование решения

Тесты, написанные на Go, находятся в папке `tests`. Выполнение тестов начинается с функции `TestHW`, которая находится в файле [hw_test.go](./tests/hw_test.go).

### Локальное тестирование

Для ускоренного тестирования при работе над решением рекомендуется запускать тесты без Docker. Для это надо установить локально Go и отредактировать при необходимости шаблон команды запуска вашего сервера в файле `tests/launch.tmpl`. Для запуска тестов перейдите в папку `tests` и выполните команду `go test`. Можно запустить только определенную группу тестов, например `go test -run 'TestHW/G1'`.

Для тестирования в окружении, аналогичном тестирующей системе, используйте команду `python3 ../cli.py test`. В этом случае тесты выполняются в Docker контейнере, внутри которого запускается контейнер (собранный по `server/Dockerfile`) с вашим сервером и ограничением по памяти в 128 MB. Время выполнения тестов в таком режиме скорее всего будет дольше. Лимит по времени установлен в 15 минут, чего должно хватить с запасом, по опыту все тесты занимают 5-10 минут.

Также можно самому собрать образ с сервером и запустить локально тесты на нём таким образом:

```
cd server
docker build -t hw3img .

cd ../tests
go test --docker
```

Аналогично можно самому собрать образ с тестами и запустить тесты в нём таким образом:

```
cd tests
docker build -t hw3tests .

cd ../
docker run --privileged --rm -t -v ./server:/hw/server hw3tests
```

### Проверка в тестирующей системе

Отправьте ваше решение в тестирующую систему следуя [инструкции](../readme.md) и дождитесь результатов.

### Структура тестов

Тесты имеют иерархическую структуру. Для того чтобы получить оценку 10, решение должно успешно пройти тесты во всех группах. Для того чтобы получить оценку за группу, решение должно успешно пройти тесты во всех запусках внутри этой группы. В каждом запуске сервер запускается один раз на одном наборе файлов и проверяется работа на наборе тестов. Запуск считается успешным, если сервер правильно обработал все запросы.

Например, `TestHW/G2/93/42300` это уникальный идентификатор одного тестового запроса:
- `G2` – имя группы,
- `93` – id запуска (в одном запуске сервер запускается один раз на одном наборе файлов),
- `42300` – id одного HTTP запроса.

Набор тестов детерминированный, и совпадает при всех выполнениях `go test`. То же самое выполняется для файлов и запросов, их содержимое зависит только от уникального идентификатора.

Если вы хотите запустить тесты только для одного запроса, это можно сделать с использованием фильтров. Например, можно запустить только самый первый запрос в самой первой группе:

```
go test -run 'TestHW/G1/1337/96006'
```

Также можно протестировать один конкретный запуск:
```
go test -run 'TestHW/G1/1337'
```

Или одну конкретную группу:
```
go test -run 'TestHW/G1'
```

Более подробные детали можно узнать прочитав исходный код тестов. 

Если вы найдете ошибки или требования из условий, которые не покрывают наши тесты, то вы можете получить за это бонусные баллы. Для этого надо включить в отчёт описание ситуации, которую не ловят тесты, добавив при необходимости пример решения с ошибкой. За это полагается 1 балл. Если вы также реализуете тесты, которые ловят найденную проблему, или хотя бы опишите их логику, то получите еще 1 балл.

### Пример запуска

После запуска тестов на экране появится лог тестирования, с примерно следующим содержимым:

```
INFO    TestHW  Starting tests
INFO    TestHW/G1       Starting tests group    {"points": 3}
INFO    TestHW/G1/42    Running command {"command": "python3 ../server/server.py --port=39371", "env": ["SERVER_PORT=80"]}
INFO    TestHW/G1/1337  Running command {"command": "python3 ../server/server.py --port=32849 --working-directory=***", "env": ["SERVER_PORT=80", "SERVER_WORKING_DIRECTORY=/"]}
DEBUG   TestHW/G1/1337  Waiting 100ms for server startup        {"attempt": 0, "error": "Get \"http://localhost:32849\": dial tcp 127.0.0.1:32849: connect: connection refused"}
INFO:__main__:Starting server on 0.0.0.0:32849, domain localhost, working directory ***
INFO:__main__:Listening at ('0.0.0.0', 32849)
...
WARN    TestHW/G1/1337  Skipping next queries because of the failed query       {"skipped": 19, "failed": "TestHW/G1/1337/96006"}
WARN    TestHW/G1       Skipping next tests in a group because last test has failed
WARN    TestHW/G1       Tests group failed      {"name": "G1", "score": 0}
INFO    TestHW/G2       Starting tests group    {"points": 1}
...
WARN    TestHW/G2       Tests group failed      {"name": "G2", "score": 0}
...
WARN    TestHW/G7       Tests group failed      {"name": "G7", "score": 0}
INFO    TestHW  Tests finished  {"score": 0}
--- FAIL: TestHW (33.28s)
    ...
    --- FAIL: TestHW/G2 (0.26s)
        --- FAIL: TestHW/G2/93 (0.26s)
            --- FAIL: TestHW/G2/93/42300 (0.00s)
                test_utils.go:36: 
                        Error:          Received unexpected error:
                                        Get "http://localhost:58785/GMR/BWYCPMQHAC/ZVCI": EOF
                        Test:           TestHW/G2/93/42300
                        Messages:       failed to run query on server
    ...
```

Так выглядит лог о начале выполнения тестов для группы, которая стоит 3 балла:
```
INFO    TestHW/G1       Starting tests group    {"points": 3}
```

При запуске решения логируются параметры запуска:
```
INFO    TestHW/G1/42    Running command {"command": "python3 ../server/server.py --port=39371", "env": ["SERVER_PORT=80"]}
```

Весь вывод решения в stdout/stderr также виден на экране:
```
INFO:__main__:Starting server on 0.0.0.0:32849, domain None, working directory ***
INFO:__main__:Listening at ('0.0.0.0', 32849)
```

При ошибке останавливается тестирование запуска и группы, оценка за группу 0 баллов:
```
WARN    TestHW/G1/1337  Skipping next queries because of the failed query       {"skipped": 19, "failed": "TestHW/G1/1337/96006"}
WARN    TestHW/G1       Skipping next tests in a group because last test has failed
WARN    TestHW/G1       Tests group failed      {"name": "G1", "score": 0}
```

В конце тестирования печатается отчет со всеми ошибками и предварительной итоговой оценкой:
```
INFO    TestHW  Tests finished  {"score": 0}
```

Обратите внимание, что чекер ожидает поднятия сервера в течение 10 секунд. Проверка осуществляется при помощи отправки запросов `GET / HTTP/1.1`, сервер должен вернуть любой корректный ответ. **Ваше решение должно уметь обрабатывать этот запрос всегда, в рамках любой группы тестов.**

Если в течение 10 секунд ваш сервер не начал отвечать на запросы, вы увидите следующую ошибку:
```
WARN	TestHW/G6/7824	Server didn't get up in time, aborting
ERROR	TestHW/G6/7824	
	Error:      	Received unexpected error:
	            	server did not start in 10 seconds
	Test:       	TestHW/G6/7824
	Messages:   	failed to wait for server
```
