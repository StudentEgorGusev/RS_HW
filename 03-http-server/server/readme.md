Лог успешного прогона (10 баллов) положил в proofs/log.txt , скрин с консоли также приложил image.png



......HTTP сервер хранилища файлов

....Питч идеи:

..Сервер - один процесс, который слушает TCP сокет, принимает одно соединение, читает один HTTP запрос, пишет один HTTP ответ и закрывает соединение

..Подмножество http/1.1 по условию: keep-alive не поддерживаю, пайплайнинг не поддерживаю, после ответа всегда закрываю

..Без готовых библотек для хттп, request line и заголовки парсятся ручками, ответ собирается ручками

..Файлы читаю и пишу потоково чанками, чтобы не держать весь файл в памяти - лимтт памяти

..Реализовано GET, POST, PUT, DELETE и заголовки Host, Accept-Encoding gzip, Create-Directory, Remove-Directory и корректные заголовки ответа Content-Length, Content-Type, Content-Encoding, Server



....Что считается:

..Request-URI как путь относительно working-directory

..в тестах пути по всей видимости простые (ASCII, без percent-encoding), поэтому я работаю с ними как с обычными posix путями





......Структура файлов решения

....server/server.py

..точка входа и основной цикл accept

..создание сокета, bind/listen

..обработка одного соединения через HTTPHandler

..маршрутизация по методу (GET/POST/PUT/DELETE)

..работа с файловой системой. чтение, запись, удаление, листинг

..формирование и оттправка HTTPResponse



....server/http\_messages.py

..структуры HTTPRequest и HTTPResponse (dataclass)

..парсер заголовков и сборка сообщений в bytes

..константы протокола: CRLF, имена заголовков, статусы, reason phrases



....server/requirements.txt

..click заготовочный для cli параметров



....server/Dockerfile

..python:3.12-slim

..установка requirements

..копирование server/ в образ

..ENTRYPOINT запускает python3 server.py



....proofs/log.txt , image.png

..лог и скрин успешного прогона тестов на 10 баллов









......Архитектура сервера

....Сокет:

..создаю socket(AF\_INET, SOCK\_STREAM)

..ставлю SO\_REUSEADDR чтобы не тормозить на TIME\_WAIT при перезапусках

..bind(host, port) и listen()



....Модель обработки:

..сервер однопоточный, условие допускает

..в бесконечном цикле accept() -> conn, addr

..на каждом conn создаю StreamRequestHandler (HTTPHandler), он читает rfile/wfile

..после handle делаю shutdown(SHUT\_WR) и close, чтобы клиент видел eof и корректно закрылся







......HTTP протокол

....Request:

..Request-Line: METHOD SP Request-URI SP HTTP/1.1 CRLF

..Пустая строка CRLF завершает заголовки

..Тело: ровно Content-Length байт, если Content-Length есть



....Response:

..Status-Line: HTTP/1.1 SP status\_code SP reason CRLF

..Пустая строка CRLF

..Body: байты тела (может быть пустое)

..длина тела либо через Content-Length, либо через закрытие соединения (для gzip)







......Парсинг запроса (ручками)

....Как читаю:

..в handler сначала читаю первую строку self.rfile.readline()

..если она пустая (клиент закрылся), просто выхожу



....Request line:

..декодирую как latin-1 (на utf-8 падало)

..сплит по пробелам на 3 части: method, path, version

..если формат не тот или version не HTTP/1.1, 400



....Заголовки:

..читаю построчно до пустой строки

..каждую строку режу по первому двоеточию :

..ключ и значение тримаю

..кладу в dict headers

..ключи храню в том виде как пришли, но ищу нужные заголовки по точному имени из констант



....Тело:

..если метод POST или PUT, пытаюсь взять Content-Length

..если Content-Length отсутствует или не число, 400

..иначе читаю N байт через self.rfile.read(N)







......Нормализация пути и защита файловой системы

....Идея:

..нельзя дать клиенту выйти выше working-directory через ../

..поэтому любой path приводится к безопасному абсолютному пути и проверяется



....Алгоритм:

..убираю ведущий / чтобы получить относительный путь

..pathlib.Path(working\_directory / relative).resolve()

..проверяю что итоговый путь всё ещё внутри working\_directory (через commonpath/parents)

..если попытка выйти наружу или путь кривой, отдаю 404









......Проверка Host (server-domain)

....Идея:

..по условию если server-domain не совпадает с Host заголовком, надо 400



....Логика:

..беру Host из заголовко; если пустой, считаю это bad request и 400

..если Host вида domain:port, сравниваю только domain часть до :

..если не равно self.server.server\_domain, 400







......Формирование HTTP ответа

....Статус и reason:

..использую таблицу HTTP\_REASON\_BY\_STATUS, чтобы формировать строку вида 404

....Заголовки ответа:

..Server: всегда, например hse-http-server

..Content-Type:  всегда (для ошибок и листинга text/plain)

..Content-Length:когда знаю длину тела заранее и не сжимаю gzip

..Content-Encoding: gzip только если реально gzip



....Как пишу:

..собираю status line+headers+ пустую строку в bytes через CRLF

..пишу их в wfile

..потом пишу тело (или стримлю файл/листинг)

..после этого handler завершается, и верхний уровень закрывает соединение









......GET {url}

....GET:

..если путь это файл, отдаю содержимое

..Content-Type определяю через mimetypes.guess\_type

..если mimetype не угадал, ставлю application/octet-stream



....GET без gzip:

..Content-Length равный размеру файла

..открываю файл в rb

..копирую в self.wfile чанками, без чтения целиком в память, раньше не проходил по времени

..это проходит тесты на бинарных файлах и на больших размерах



....GET с gzip:

..если Accept-Encoding содержит gzip, сжатие

..ставлю Content-Encoding: gzip

..Content-Length не ставлю, потому что gzip потоковый 

..wfile в gzip.GzipFile(fileobj=self.wfile, mode=wb)

..стримлю файл чанками в gzip stream



....GET директория:

..если путь это директория, возвращаю листинг как текст/plain



....Формат строки листинга:

..mode uid gid size mtime name

..mode беру через stat.filemode

..uid/gid беру как числа из st\_uid/st\_gid 

..mtime форматирую как YYYY-MM-DD HH:MM:SS (через datetime/fromtimestamp или time.localtime)



....GET директория с gzip:

..если запрошен gzip, листинг тоже сжимаю так же как файл

..Content-Encoding gzip, без Content-Length



....GET несуществующий путь:

..404









......POST {url}

....Идея:

..POST создаёт новый файл или директорию

..директория создаётся только если заголовок Create-Directory: True



....Проверки:

..если целевой путь уже существует (файл или директория), 409

..если родительской директории нет, 404 и ничего не создаю





....POST Create-Directory True:

..создаю директорию через mkdir

..ответ 200 (или 201 не принципиально для тестов, но 200 стабильнее)



....POST создание файла:

..Content-Length обязателен, читаю тело ровно N байт

..пишу данные потоково: читаю из сокета кусками и пишу

..200









......PUT {url}

....Идея:

..PUT обновляет существующий файл, полностью заменяя содержимое телом запроса



....Проверки:

..если путь указывает на директорию, 409

..если файла нет, 404 и не создаю новый







......DELETE {url}

....Идея:

..удаляет файл или директорию - логично!

..для директории нужен заголовок Remove-Directory: True, иначе 406



....Проверки:

..если путь не существует, 404

..если это директория и Remove-Directory не тру, 406



....Удаление:

..файл: unlink()

..директория: shutil.rmtree()

..при успехе 200









......Заголовки из условий

....Host (request):

..проверяю на совпадение с server-domain, иначе 400



....Accept-Encoding (request):

..если содержит gzip, то для GET ответа включаю gzip

..если нет, то нет



....Create-Directory (request):

..обрабатываю только для post

..true создаёт директорию, иначе считаю за создание файла



....Remove-Directory (request):

..обрабатываю только для delete

..без него удаление директории запрещено 



....Content-Length (request):

..использую для чтения тела post/put

..если нет или битый, 400



....Content-Length (response):

..ставлю всегда для несжатых ответов с известным размером

..а для gzip ответов не ставлю, граница по закрытию соединения



....Content-Type (response):

..для файлов: mimetypes

..для листинга и ошибок: text/plain



....Content-Encoding (response):

..gzip если реально отдаю gzip



....Server (response):

..ставлю всегда, чтобы проходить проверки групп G5/G7















......Используемые библиотеки

....Внешние:

..click (из заготовки) для CLI



....Стандартная библиотека:

..socket, socketserver.StreamRequestHandler для TCP сервера и удобного rfile/wfile

..pathlib, os, shutil для файловой системы

..gzip для Content-Encoding gzip

..mimetypes для Content-Type

..stat, datetime/time для прав, размера и времени при листинге директории

..logging для локального дебага (не влияет на протокол)









......Итог

..сервер реализует требуемое подмножество HTTP/1.1 ручками (моими)

..все методы GET/POST/PUT/DELETE работают на файлах и директориях по условиюю

..валидация Host относительно server-domain реализована (400 на несовпадение)

..gzip поддержан для GET и работает потоково

